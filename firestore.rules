/**
 * @file Firestore Security Rules for Aravalli Home Studio.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private user data (orders, recommendations) and allows public read access to product and gallery information.
 *
 * Data Structure:
 * - Products: Stored in the `/products` collection, accessible to all for reading.
 * - Users: Each user has a dedicated document at `/users/{userId}`, where `userId` matches their Firebase Authentication UID.
 * - Orders: Nested under `/users/{userId}/orders/{orderId}`, ensuring user-ownership. The `customerId` field within the Order document duplicates the user id for authorization purposes
 * - OrderItems: Nested under `/users/{userId}/orders/{orderId}/order_items/{orderItemId}`.
 * - Recommendations: Nested under `/users/{userId}/recommendations/{recommendationId}`, ensuring user-ownership. The `customerId` field within the Recommendation document duplicates the user id for authorization purposes
 * - Greetings: Stored in the `/greetings` collection, accessible to all for reading.
 * - Gallery Items: Stored in the `/gallery_items` collection, accessible to all for reading.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public read access is granted for products, greetings, and gallery items.
 * - All write operations (create, update, delete) require user authentication.
 * - Data validation is limited to enforcing relationships and ownership.
 *
 * Denormalization for Authorization:
 * - Orders and Recommendations duplicate the `customerId` field to enable authorization checks within the document itself.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to the products collection, with owner-only writes.
     * @path /products/{productId}
     * @allow get, list: if true;
     * @deny create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Allows public reads, requires ownership for writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages customer orders, enforcing user-ownership via path and customerId.
     * @path /users/{userId}/orders/{orderId}
     * @allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.customerId == userId;
     * @allow get: if isOwner(userId);
     * @allow list: if isOwner(userId);
     * @allow update: if isExistingOwner(userId) && request.resource.data.customerId == resource.data.customerId;
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @deny update: if request.resource.data.customerId != resource.data.customerId;
     * @principle Enforces document ownership for reads and writes, validates customerId on create.
     */
    match /users/{userId}/orders/{orderId} {
      allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.customerId == userId;
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.customerId == resource.data.customerId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages order items, enforcing user-ownership inherited from the parent order.
     * @path /users/{userId}/orders/{orderId}/order_items/{orderItemId}
     * @allow create: if isOrderOwner(userId, orderId);
     * @allow get: if isOrderOwner(userId, orderId);
     * @allow list: if isOrderOwner(userId, orderId);
     * @allow update: if isOrderOwner(userId, orderId) && resource != null;
     * @allow delete: if isOrderOwner(userId, orderId) && resource != null;
     * @deny create: if !isOrderOwner(userId, orderId);
     * @principle Inherits ownership from the parent order document.
     */
    match /users/{userId}/orders/{orderId}/order_items/{orderItemId} {
      allow create: if isOrderOwner(userId, orderId);
      allow get: if isOrderOwner(userId, orderId);
      allow list: if isOrderOwner(userId, orderId);
      allow update: if isOrderOwner(userId, orderId) && resource != null;
      allow delete: if isOrderOwner(userId, orderId) && resource != null;
    }

    /**
     * @description Enforces user-ownership for customer profiles, using the Firebase Auth UID as the document ID.
     * @path /users/{userId}
     * @allow create: if isSignedIn() && request.auth.uid == userId;
     * @allow get: if isOwner(userId);
     * @allow list: if false;
     * @allow update: if isExistingOwner(userId);
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @principle Enforces strict user-ownership based on Firebase Auth UID.
     */
    match /users/{userId} {
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow get: if isOwner(userId);
      allow list: if false;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to greeting messages.
     * @path /greetings/{greetingId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false; // TODO: Add admin-only writes once roles are defined.
     * @principle Provides public read access.
     */
    match /greetings/{greetingId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin-only writes once roles are defined.
    }

    /**
     * @description Allows public read access to gallery items.
     * @path /gallery_items/{galleryItemId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;  // TODO: Add admin-only writes once roles are defined.
     * @principle Provides public read access.
     */
    match /gallery_items/{galleryItemId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin-only writes once roles are defined.
    }

    /**
     * @description Manages product recommendations, enforcing user-ownership via path and customerId.
     * @path /users/{userId}/recommendations/{recommendationId}
     * @allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.customerId == userId;
     * @allow get: if isOwner(userId);
     * @allow list: if isOwner(userId);
     * @allow update: if isExistingOwner(userId) && request.resource.data.customerId == resource.data.customerId;
     * @allow delete: if isExistingOwner(userId);
     * @deny create: if !isSignedIn() || request.auth.uid != userId;
     * @deny update: if request.resource.data.customerId != resource.data.customerId;
     * @principle Enforces document ownership for reads and writes, validates customerId on create.
     */
    match /users/{userId}/recommendations/{recommendationId} {
      allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.customerId == userId;
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.customerId == resource.data.customerId;
      allow delete: if isExistingOwner(userId);
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    function isOrderOwner(userId, orderId) {
        return get(/databases/$(database)/documents/users/$(userId)/orders/$(orderId)).data.customerId == userId && isSignedIn();
    }
  }
}